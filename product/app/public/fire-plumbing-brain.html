<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JOC Brain - 7,166 Fire Protection & Plumbing Items</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a12;
      font-family: 'Inter', -apple-system, sans-serif;
      color: white;
      overflow: hidden;
    }
    
    #header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 24px;
      background: linear-gradient(180deg, rgba(10,10,18,0.98) 0%, transparent 100%);
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #header h1 {
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #header h1 .fire { color: #ef4444; }
    #header h1 .plumb { color: #3b82f6; }
    #header h1 .sep { color: rgba(255,255,255,0.3); }
    
    #header .stats {
      display: flex;
      gap: 20px;
    }
    
    #header .stat {
      text-align: center;
    }
    
    #header .stat-value {
      font-size: 22px;
      font-weight: 700;
    }
    
    #header .stat-value.fire { color: #ef4444; }
    #header .stat-value.plumb { color: #3b82f6; }
    #header .stat-value.total { color: #f59e0b; }
    
    #header .stat-label {
      font-size: 9px;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #canvas-container {
      width: 100vw;
      height: 100vh;
    }
    
    canvas {
      display: block;
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
    }
    
    #loading h2 {
      font-size: 24px;
      margin-bottom: 16px;
    }
    
    #loading .progress {
      width: 300px;
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
    }
    
    #loading .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ef4444, #3b82f6);
      width: 0%;
      transition: width 0.3s;
    }
    
    #loading .count {
      margin-top: 12px;
      font-size: 14px;
      color: rgba(255,255,255,0.6);
    }
    
    #tooltip {
      position: fixed;
      padding: 12px 16px;
      background: rgba(0,0,0,0.95);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
      max-width: 350px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    
    #tooltip.visible { opacity: 1; }
    
    #tooltip h3 {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
    }
    
    #tooltip .code {
      font-family: monospace;
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      margin-bottom: 6px;
    }
    
    #tooltip .price {
      font-size: 14px;
      font-weight: 600;
      color: #10b981;
    }
    
    #legend {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.85);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
    }
    
    #legend h4 {
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    #controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    #controls button {
      padding: 10px 18px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    #controls button:hover {
      background: rgba(255,255,255,0.15);
    }
    
    #controls button.active {
      border-color: #f59e0b;
      color: #f59e0b;
      background: rgba(245,158,11,0.1);
    }
    
    #search-box {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
    }
    
    #search-box input {
      width: 400px;
      padding: 12px 20px;
      background: rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 25px;
      color: white;
      font-size: 14px;
      outline: none;
    }
    
    #search-box input:focus {
      border-color: #f59e0b;
    }
    
    #search-box input::placeholder {
      color: rgba(255,255,255,0.4);
    }
    
    #message {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(245,158,11,0.2);
      border: 1px solid rgba(245,158,11,0.4);
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 13px;
      color: #fbbf24;
      text-align: center;
      max-width: 500px;
    }
    
    #message strong { color: white; }
  </style>
</head>
<body>
  <div id="header">
    <h1>
      ðŸ§  JOC Brain: 
      <span class="fire">Fire Protection</span>
      <span class="sep">&</span>
      <span class="plumb">Plumbing</span>
    </h1>
    <div class="stats">
      <div class="stat">
        <div class="stat-value fire" id="fp-count">1,073</div>
        <div class="stat-label">Div 21 Items</div>
      </div>
      <div class="stat">
        <div class="stat-value plumb" id="plumb-count">6,093</div>
        <div class="stat-label">Div 22 Items</div>
      </div>
      <div class="stat">
        <div class="stat-value total" id="total-count">7,166</div>
        <div class="stat-label">Total Items</div>
      </div>
    </div>
  </div>
  
  <div id="loading">
    <h2>Loading 7,166 JOC Items...</h2>
    <div class="progress">
      <div class="progress-bar" id="progress-bar"></div>
    </div>
    <div class="count" id="loading-count">0 / 7,166</div>
  </div>
  
  <div id="search-box">
    <input type="text" id="search" placeholder="Search: sprinkler, pipe, drain, valve..." />
  </div>
  
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  
  <div id="tooltip"></div>
  
  <div id="legend">
    <h4>JOC Complexity Map</h4>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ef4444; width: 16px; height: 16px;"></div>
      <span>Category Hub (FP)</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #3b82f6; width: 16px; height: 16px;"></div>
      <span>Category Hub (Plumb)</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ef4444;"></div>
      <span>Fire Protection Item</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #3b82f6;"></div>
      <span>Plumbing Item</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #f59e0b;"></div>
      <span>Search Match</span>
    </div>
    <div class="legend-item" style="margin-top: 10px; color: rgba(255,255,255,0.5); font-size: 10px;">
      Lines = category relationships
    </div>
  </div>
  
  <div id="controls">
    <button id="btn-all" class="active">All 7,166</button>
    <button id="btn-fp">ðŸ”´ Fire Only</button>
    <button id="btn-plumb">ðŸ”µ Plumbing Only</button>
    <button id="btn-chaos">ðŸ’¥ Max Chaos</button>
    <button id="btn-cluster">ðŸ“Š Cluster</button>
    <button id="btn-links" class="active">ðŸ”— Links</button>
  </div>
  
  <div id="message">
    <strong>This is the complexity.</strong> Every dot is a real JOC line item that contractors navigate daily. 
    JOCHero tames this chaos with smart assemblies.
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const width = window.innerWidth;
    const height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    const tooltip = document.getElementById('tooltip');
    const loading = document.getElementById('loading');
    const progressBar = document.getElementById('progress-bar');
    const loadingCount = document.getElementById('loading-count');
    
    let items = [];
    let nodes = [];
    let categoryHubs = [];
    let links = [];
    let simulation = null;
    let currentFilter = 'all';
    let searchTerm = '';
    let highlightedNodes = new Set();
    let showLinks = true;
    
    // Colors
    const COLORS = {
      fp: '#ef4444',
      plumb: '#3b82f6',
      highlight: '#f59e0b',
      fpDim: 'rgba(239, 68, 68, 0.3)',
      plumbDim: 'rgba(59, 130, 246, 0.3)'
    };
    
    // Load data
    async function loadData() {
      try {
        const response = await fetch('/data/fp-plumbing-catalogue.json');
        items = await response.json();
        
        // Update counts
        const fpItems = items.filter(i => i.taskCode.startsWith('21'));
        const plumbItems = items.filter(i => i.taskCode.startsWith('22'));
        document.getElementById('fp-count').textContent = fpItems.length.toLocaleString();
        document.getElementById('plumb-count').textContent = plumbItems.length.toLocaleString();
        document.getElementById('total-count').textContent = items.length.toLocaleString();
        
        initNodes();
      } catch (e) {
        console.error('Failed to load data:', e);
        loading.innerHTML = '<h2 style="color: #ef4444;">Failed to load data</h2>';
      }
    }
    
    function initNodes() {
      // First, build category hubs
      const categoryMap = new Map();
      
      items.forEach(item => {
        const cat = item.taskCode.substring(0, 8);
        if (!categoryMap.has(cat)) {
          categoryMap.set(cat, { count: 0, isFP: item.taskCode.startsWith('21') });
        }
        categoryMap.get(cat).count++;
      });
      
      // Create hub nodes for each category
      categoryHubs = [];
      let hubIndex = 0;
      categoryMap.forEach((data, catId) => {
        const angle = (hubIndex / categoryMap.size) * Math.PI * 2;
        const radius = 250;
        categoryHubs.push({
          id: `hub-${catId}`,
          catId: catId,
          isHub: true,
          isFP: data.isFP,
          count: data.count,
          x: width / 2 + Math.cos(angle) * radius,
          y: height / 2 + Math.sin(angle) * radius,
          vx: 0,
          vy: 0,
          radius: Math.min(8 + data.count / 20, 25),
          color: data.isFP ? COLORS.fp : COLORS.plumb
        });
        hubIndex++;
      });
      
      // Create item nodes
      nodes = items.map((item, i) => {
        const isFP = item.taskCode.startsWith('21');
        const category = item.taskCode.substring(0, 8);
        
        // Find parent hub
        const hub = categoryHubs.find(h => h.catId === category);
        
        // Random position near hub
        const angle = Math.random() * Math.PI * 2;
        const radius = 30 + Math.random() * 100;
        
        return {
          id: item.taskCode,
          description: item.description,
          unit: item.unit,
          unitCost: item.unitCost,
          category: category,
          hubId: hub ? hub.id : null,
          isFP: isFP,
          x: (hub ? hub.x : width / 2) + Math.cos(angle) * radius,
          y: (hub ? hub.y : height / 2) + Math.sin(angle) * radius,
          vx: 0,
          vy: 0,
          radius: 2.5,
          color: isFP ? COLORS.fp : COLORS.plumb
        };
      });
      
      // Build links - connect items to their category hub
      links = [];
      nodes.forEach(node => {
        if (node.hubId) {
          links.push({ source: node, target: categoryHubs.find(h => h.id === node.hubId) });
        }
      });
      
      // Add some cross-category links for "complexity" visual (random 1% of items)
      const crossLinkCount = Math.floor(nodes.length * 0.01);
      for (let i = 0; i < crossLinkCount; i++) {
        const a = nodes[Math.floor(Math.random() * nodes.length)];
        const b = nodes[Math.floor(Math.random() * nodes.length)];
        if (a.category !== b.category) {
          links.push({ source: a, target: b, isCross: true });
        }
      }
      
      // Update progress
      progressBar.style.width = '100%';
      loadingCount.textContent = `${items.length.toLocaleString()} items + ${categoryHubs.length} categories`;
      setTimeout(() => {
        loading.style.opacity = '0';
        setTimeout(() => loading.style.display = 'none', 300);
      }, 500);
      
      startSimulation();
    }
    
    function startSimulation(mode = 'cluster') {
      if (simulation) simulation.stop();
      
      // Filter nodes and hubs based on current filter
      let activeNodes = nodes;
      let activeHubs = categoryHubs;
      if (currentFilter === 'fp') {
        activeNodes = nodes.filter(n => n.isFP);
        activeHubs = categoryHubs.filter(h => h.isFP);
      } else if (currentFilter === 'plumb') {
        activeNodes = nodes.filter(n => !n.isFP);
        activeHubs = categoryHubs.filter(h => !h.isFP);
      }
      
      // Combine hubs and nodes for simulation
      const allNodes = [...activeHubs, ...activeNodes];
      
      // Filter links
      const activeLinks = links.filter(l => {
        const sourceActive = activeNodes.includes(l.source) || activeHubs.includes(l.source);
        const targetActive = activeNodes.includes(l.target) || activeHubs.includes(l.target);
        return sourceActive && targetActive;
      });
      
      // Different force configurations
      let chargeStrength, centerStrength, linkStrength;
      
      if (mode === 'chaos') {
        chargeStrength = -8;
        centerStrength = 0.005;
        linkStrength = 0.01;
      } else {
        chargeStrength = -4;
        centerStrength = 0.02;
        linkStrength = 0.05;
      }
      
      simulation = d3.forceSimulation(allNodes)
        .force('charge', d3.forceManyBody().strength(d => d.isHub ? chargeStrength * 5 : chargeStrength))
        .force('center', d3.forceCenter(width / 2, height / 2).strength(centerStrength))
        .force('collision', d3.forceCollide().radius(d => d.radius + 2))
        .force('link', d3.forceLink(activeLinks).strength(linkStrength).distance(50))
        .force('x', d3.forceX(d => {
          if (mode === 'cluster') {
            return d.isFP ? width * 0.35 : width * 0.65;
          }
          return width / 2;
        }).strength(mode === 'cluster' ? 0.08 : 0))
        .force('y', d3.forceY(height / 2).strength(0.03))
        .alphaDecay(0.008)
        .on('tick', render);
    }
    
    function render() {
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, width, height);
      
      // Draw links first (behind nodes)
      if (showLinks) {
        ctx.globalAlpha = 0.08;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.5;
        
        links.forEach(link => {
          if (!link.source || !link.target) return;
          if (currentFilter === 'fp' && (!link.source.isFP || !link.target.isFP)) return;
          if (currentFilter === 'plumb' && (link.source.isFP || link.target.isFP)) return;
          
          ctx.beginPath();
          ctx.moveTo(link.source.x, link.source.y);
          ctx.lineTo(link.target.x, link.target.y);
          ctx.stroke();
        });
        
        ctx.globalAlpha = 1;
      }
      
      // Draw category hub nodes (larger, with glow)
      categoryHubs.forEach(hub => {
        if (currentFilter === 'fp' && !hub.isFP) return;
        if (currentFilter === 'plumb' && hub.isFP) return;
        
        // Glow
        ctx.beginPath();
        ctx.arc(hub.x, hub.y, hub.radius + 5, 0, Math.PI * 2);
        ctx.fillStyle = hub.isFP ? 'rgba(239, 68, 68, 0.2)' : 'rgba(59, 130, 246, 0.2)';
        ctx.fill();
        
        // Hub
        ctx.beginPath();
        ctx.arc(hub.x, hub.y, hub.radius, 0, Math.PI * 2);
        ctx.fillStyle = hub.color;
        ctx.fill();
        
        // Border
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
      });
      
      // Draw item nodes
      nodes.forEach(node => {
        if (currentFilter === 'fp' && !node.isFP) return;
        if (currentFilter === 'plumb' && node.isFP) return;
        
        const isHighlighted = highlightedNodes.has(node.id);
        const isDimmed = highlightedNodes.size > 0 && !isHighlighted;
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, isHighlighted ? 5 : node.radius, 0, Math.PI * 2);
        
        if (isHighlighted) {
          ctx.fillStyle = COLORS.highlight;
          ctx.shadowColor = COLORS.highlight;
          ctx.shadowBlur = 10;
        } else if (isDimmed) {
          ctx.fillStyle = node.isFP ? COLORS.fpDim : COLORS.plumbDim;
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = node.color;
          ctx.shadowBlur = 0;
        }
        
        ctx.fill();
      });
      
      ctx.shadowBlur = 0;
    }
    
    // Mouse interaction
    let hoveredNode = null;
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      
      // Find closest node
      let closest = null;
      let closestDist = 20; // Max distance to trigger hover
      
      nodes.forEach(node => {
        if (currentFilter === 'fp' && !node.isFP) return;
        if (currentFilter === 'plumb' && node.isFP) return;
        
        const dist = Math.hypot(node.x - mx, node.y - my);
        if (dist < closestDist) {
          closest = node;
          closestDist = dist;
        }
      });
      
      if (closest !== hoveredNode) {
        hoveredNode = closest;
        
        if (closest) {
          showTooltip(e, closest);
        } else {
          hideTooltip();
        }
      }
      
      if (hoveredNode) {
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
      }
    });
    
    function showTooltip(e, node) {
      const divName = node.isFP ? 'Fire Protection' : 'Plumbing';
      const divColor = node.isFP ? COLORS.fp : COLORS.plumb;
      
      tooltip.innerHTML = `
        <h3 style="color: ${divColor}">${node.description}</h3>
        <div class="code">${node.id}</div>
        <div class="price">$${node.unitCost.toFixed(2)} / ${node.unit}</div>
      `;
      tooltip.classList.add('visible');
    }
    
    function hideTooltip() {
      tooltip.classList.remove('visible');
    }
    
    // Search
    let searchTimeout;
    document.getElementById('search').addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchTerm = e.target.value.toLowerCase();
        
        highlightedNodes.clear();
        
        if (searchTerm.length >= 2) {
          nodes.forEach(node => {
            if (node.description.toLowerCase().includes(searchTerm) ||
                node.id.toLowerCase().includes(searchTerm)) {
              highlightedNodes.add(node.id);
            }
          });
        }
        
        render();
      }, 200);
    });
    
    // Controls
    function setActiveButton(id) {
      document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }
    
    document.getElementById('btn-all').addEventListener('click', () => {
      setActiveButton('btn-all');
      currentFilter = 'all';
      startSimulation('cluster');
    });
    
    document.getElementById('btn-fp').addEventListener('click', () => {
      setActiveButton('btn-fp');
      currentFilter = 'fp';
      startSimulation('cluster');
    });
    
    document.getElementById('btn-plumb').addEventListener('click', () => {
      setActiveButton('btn-plumb');
      currentFilter = 'plumb';
      startSimulation('cluster');
    });
    
    document.getElementById('btn-chaos').addEventListener('click', () => {
      setActiveButton('btn-chaos');
      currentFilter = 'all';
      startSimulation('chaos');
    });
    
    document.getElementById('btn-cluster').addEventListener('click', () => {
      setActiveButton('btn-cluster');
      currentFilter = 'all';
      startSimulation('cluster');
    });
    
    document.getElementById('btn-links').addEventListener('click', () => {
      showLinks = !showLinks;
      document.getElementById('btn-links').classList.toggle('active', showLinks);
      render();
    });
    
    // Resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (simulation) {
        simulation.force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
        simulation.alpha(0.3).restart();
      }
    });
    
    // Start
    loadData();
  </script>
</body>
</html>
